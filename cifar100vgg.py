# -*- coding: utf-8 -*-
"""CIFAR100VGG.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14Iiin2sn6eIlL5q3XqYREARsnHz0yFG0
"""

import tensorflow as tf
from tensorflow.keras.models import Model, load_model
from tensorflow.keras import layers, Input, Sequential, applications
from tensorflow.keras.layers import Dense, Flatten, Dropout
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.preprocessing.image import ImageDataGenerator
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import OneHotEncoder
import random

"""# **Loading and Preprocessing**"""

cifar100=tf.keras.datasets.cifar100
(X_train, y_train), (X_test, y_test)= cifar100.load_data(label_mode='fine')
y_train = OneHotEncoder().fit_transform(np.array(y_train).reshape(-1,1)).toarray()
y_test = OneHotEncoder().fit_transform(np.array(y_test).reshape(-1,1)).toarray()

X_train, X_test=X_train/255.0, X_test/255.0
HALF_WIDTH=256
WIDTH=512
batch_size=100
input_tensor= Input(shape=(32,32,3))
EPOCHS=150

"""## **Models and Utils**"""

def VGG19(input_tensor, trainable=False):
  vgg= applications.VGG19(weights='imagenet',
                               include_top=False,
                               input_tensor=input_tensor)
  for layers in vgg.layers:
    layers.trainable=trainable
  return vgg

def SpinalNetFC(vgg):
  x=Flatten()(vgg.output)

  x=(x[:, 0:HALF_WIDTH])
  x1=Dense(WIDTH, activation='relu')(x)

  x2=(tf.concat([x1,x[:,HALF_WIDTH: HALF_WIDTH*2]], axis=1))
  x2=Dense(WIDTH, activation='relu')(x2)
  
  x3=(tf.concat([x2,x[:,0: HALF_WIDTH]], axis=1))
  x3=Dense(WIDTH, activation='relu')(x3)
  
  x4=(tf.concat([x3,x[:,HALF_WIDTH: HALF_WIDTH*2]], axis=1))
  x4=Dense(WIDTH, activation='relu')(x4)
  
  x=tf.concat([x1,x2], axis=1)
  x=tf.concat([x,x3], axis=1)
  x=tf.concat([x,x4], axis=1)

  output=Dense(100, activation='softmax')(x)

  return Model(vgg.input,outputs=output)

def normalModel(vgg):
  x=Flatten()(vgg.output)

  x=Dense(4096, activation='relu')(x)

  x=Dense(4096, activation='relu')(x)

  x=Dense(100, activation='softmax')(x)

  return Model(vgg.input, outputs=x)

def plot_graph(history={}, metrics=[], width=10, height=4):
  f=plt.figure()
  f.set_figwidth(width)
  f.set_figheight(height)
  for metric in metrics:
    plt.plot(history[metric], label=metric)
  plt.legend()
  plt.grid()
  plt.show()

"""**Data Augmentation, Training, and Validation**"""

def data_augmentation(X_train, y_train, batch_size, width_shift_range=0.1, height_shift_range=0.1, horizontal_flip=False, vertical_flip=False, shear_range=0):
  data_generator=tf.keras.preprocessing.image.ImageDataGenerator(width_shift_range=width_shift_range, height_shift_range=height_shift_range, horizontal_flip=horizontal_flip, shear_range=shear_range)
  return data_generator.flow(X_train, y_train, batch_size)

def train_model(model, X_train, y_train, epochs, learning_rate=0.0001):
  model.compile(loss='categorical_crossentropy', optimizer=Adam(learning_rate=learning_rate), metrics=['accuracy'])

  steps_per_epoch=X_train.shape[0]//batch_size

  training_data=data_augmentation(X_train, y_train, batch_size=100, width_shift_range=0.2, height_shift_range=0.2, horizontal_flip=True, shear_range=0.2)
  
  return model.fit(training_data, validation_data=(X_test, y_test), steps_per_epoch=steps_per_epoch, epochs=epochs)

def predict(model, X):
  return model.predict(X.reshape(-1,32,32,3)).argmax()

"""#**First Training Cycle (75 Epochs)**

**Spinal Net**
"""

spinal_net_model=SpinalNetFC(VGG19(input_tensor, trainable=True))
spinal_net_model.summary()

spinal_r=train_model(spinal_net_model, X_train, y_train, epochs=EPOCHS//2)

plot_graph(spinal_r.history, ['accuracy', 'val_accuracy'])

plot_graph(spinal_r.history, ['loss', 'val_loss'])

spinal_net_history_full={}
for key in spinal_r.history.keys():
    spinal_net_history_full[key]=spinal_r.history[key]

"""**Normal NN**"""

normal_model=normalModel(VGG19(input_tensor, trainable=True))
normal_model.summary()

normal_r=train_model(normal_model, X_train, y_train, epochs=EPOCHS//2)

plot_graph(normal_r.history, ['accuracy', 'val_accuracy'])

plot_graph(normal_r.history, ['loss', 'val_loss'])

normal_nn_history_full={}
for key in normal_r.history.keys():
    normal_nn_history_full[key]=normal_r.history[key]

"""**Spinal Net vs Normal NN**"""

plot_graph({'spinal_net_accuracy': spinal_r.history['val_accuracy'], 'normal_nn_accuracy':normal_r.history['val_accuracy']}, ['spinal_net_accuracy','normal_nn_accuracy'])

plot_graph({'spinal_net_loss': spinal_r.history['val_loss'], 'normal_nn_loss':normal_r.history['val_loss']}, ['spinal_net_loss','normal_nn_loss'])

"""# **Second Training Cycle (75 Epochs)**

**Spinal Net**
"""

spinal_r=train_model(spinal_net_model, X_train, y_train, epochs=EPOCHS//2, learning_rate=0.00001)

plot_graph([spinal_r.history], ['accuracy', 'val_accuracy'])

plot_graph([spinal_r.history], ['loss', 'val_loss'])

for key in spinal_r.history.keys():
    spinal_net_history_full[key]+=spinal_r.history[key]

spinal_net_model.save('./SpinalNetCifar100.hdf5')
SNH=open('SpinalNetHistory.txt', 'w')
SNH.write(str(spinal_net_history_full))
SNH.close()

"""**Normal NN**"""

normal_r=train_model(normal_model, X_train, y_train, epochs=EPOCHS//2, learning_rate=0.00001)

plot_graph(normal_r.history, ['accuracy', 'val_accuracy'])

plot_graph(normal_r.history, ['loss', 'val_loss'])

for key in normal_r.history.keys():
    normal_nn_history_full[key]+=normal_r.history[key]

normal_model.save('./NormalNNCifar100.hdf5')
nn=open('NormalNNHistory.txt', 'w')
nn.write(str(normal_nn_history_full))
nn.close()

"""**Spinal Net vs Normal NN**"""

plot_graph({'spinal_net_accuracy': spinal_r.history['val_accuracy'], 'normal_nn_accuracy':normal_r.history['val_accuracy']}, ['spinal_net_accuracy','normal_nn_accuracy'])

plot_graph({'spinal_net_loss': spinal_r.history['val_loss'], 'normal_nn_loss':normal_r.history['val_loss']}, ['spinal_net_loss','normal_nn_loss'])

"""# **Evaluation and Prediction**"""

[sn_loss,sn_accuracy]=spinal_net_model.evaluate(X_test, y_test)
[normalnn_loss, normalnn_accuracy]=normal_model.evaluate(X_test, y_test)

print("SpinalNet Loss: "+ str(sn_loss) +", Normal NN Loss: "+ str(normalnn_loss))
print("SpinalNet Accuracy: "+ str(sn_accuracy*100)+"%"+", Normal NN Accuracy: "+str(normalnn_accuracy*100)+"%")

noOfPredictions=10
for i in range(noOfPredictions):
  i=random.randrange(10000)

  print("\nSample",i)
  plt.imshow(X_test[i])
  plt.show()

  sn_prediction=predict(spinal_net_model, X_test[i])
  nn_prediction=predict(normal_model, X_test[i])
  true_label=y_test[i].argmax()

  print("True Label:",true_label)
  print("SpinalNet Prediction:", sn_prediction)
  print("Normal NN Prediction:", nn_prediction)